# Leetcode - Algorithm
* [Two Pointers](#Two-Pointers)
    * [167. Two Sum II](#167-Two-Sum-II)
    * [633. Sum of Square Numbers](#633-Sum-of-Square-Numbers)
    * [345. Reverse Vowels of a String](#345-Reverse-Vowels-of-a-String)
    * [680. Valid Palindrome II](#680-Valid-Palindrome-II)
    * [88. Merge Sorted Array](#88-Merge-Sorted-Array)
    * [141. Linked List Cycle](#141-Linked-List-Cycle)
    * [524. Longest Word in Dictionary through Deleting](#524-Longest-Word-in-Dictionary-through-Deleting)
* [Sorting](#Sorting)
    * [215. Kth Largest Element in an Array](#215-Kth-Largest-Element-in-an-Array)
    * [347. Top K Frequent Elements](#347-Top-K-Frequent-Elements)
    * [451. Sort Characters By Frequency](#451-Sort-Characters-By-Frequency)
    * [75. Sort Colors](#75-Sort-Colors)
* [Greedy](#Greedy)
    * [455. Assign Cookies](#455-Assign-Cookies)
    * [435. Non overlapping Intervals](#435-Non-overlapping-Intervals)
    * [452. Minimum Number of Arrows to Burst Balloons](#452-Minimum-Number-of-Arrows-to-Burst-Balloons)
    * [406. Queue Reconstruction by Height](#406-Queue-Reconstruction-by-Height)
    * [121. Best Time to Buy and Sell Stock](#121-Best-Time-to-Buy-and-Sell-Stock)
    * [122. Best Time to Buy and Sell Stock II](#122-Best-Time-to-Buy-and-Sell-Stock-II)
    * [392. Is Subsequence](#392-Is-Subsequence)
    * [665. Non decreasing Array](#665-Non-decreasing-Array)
    * [53. Maximum Subarray](#53-Maximum-Subarray)
    * [763. Partition Labels](#763-Partition-Labels)
* [Divide and Conquer](#Divide-and-Conquer)
    * [241. Different Ways to Add Parentheses](#241-Different-Ways-to-Add-Parentheses)
    * [96. Unique Binary Search Trees]([#96-Unique-Binary-Search-Trees)
    * [95. Unique Binary Search Trees II](#95-Unique-Binary-Search-Trees-II)
* [Binary Search](#Binary-Search)
    * [69. Sqrt x](#69-Sqrt-x)
    * [744. Find Smallest Letter Greater Than Target](#744-Find-Smallest-Letter-Greater-Than-Target)
    * [540. Single Element in a Sorted Array](#540-Single-Element-in-a-Sorted-Array)
    * [278. First Bad Version](#278-First-Bad-Version)
    * [153. Find Minimum in Rotated Sorted Array](#153-Find-Minimum-in-Rotated-Sorted-Array)
    * [34. Find First and Last Position of Element in Sorted Array](#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array)
* [Search](#Search)
	* [BFS](#BFS)
		* [1091. Shortest Path in Binary Matrix](#1091-Shortest-Path-in-Binary-Matrix)
		* [279. Perfect Squares](#279-Perfect-Squares) 
		* [127. Word Ladder](#127-Word-Ladder)
	* [DFS](#DFS)
		* [695. Max Area of Island](#695-Max-Area-of-Island)
		* [200. Number of Islands](#200-Number-of-Islands)
		* [547. Number of Provinces](#547-Number-of-Provinces)
		* [130. Surrounded Regions](#130-Surrounded-Regions)
		* [417. Pacific Atlantic Water Flow](#417-Pacific-Atlantic-Water-Flow)
	* [Backtracking](#Backtracking)
		* [17. Letter Combinations of a Phone Number](#17-Letter-Combinations-of-a-Phone-Number)
		* [78. Subsets](#78-Subsets)
		* [90. Subsets II](#90-Subsets-II)
		* [77. Combinations](#77-Combinations)
		* [39. Combination Sum](#39-Combination-Sum)
		* [40. Combination Sum II](#40-Combination-Sum-II)
		* [216. Combination Sum III](#216-Combination-Sum-III)
		* [46. Permutations](#46-Permutations)
		* [47. Permutations II](#47-Permutations-II)
		* [131. Palindrome Partitioning](#131-Palindrome-Partitioning)
		* [267. Palindrome Permutation II](#267-Palindrome-Permutation-II)
		* [93. Restore IP Addresses](#93-Restore-IP-Addresses)
		* [79. Word Search](#79-Word-Search)
		* [257. Binary Tree Paths](#257-Binary-Tree-Paths)
		* [37. Sudoku Solver](#37-Sudoku-Solver)
		* [51. N Queens](#51-N-Queens)
* [Dynamic Programming](#Dynamic-Programming)
	* [Fibonacci](#Fibonacci)
		* [70. Climbing Stairs](#70-Climbing-Stairs)
		* [198. House Robber](#198-House-Robber)
		* [213. House Robber II](#213-House-Robber-II)
		* [Mail Misalignment](#Mail-Misalignment)
		* [Cow](#Cow)
	* [Matrix Path](#Matrix-Path) 
		* [64. Minimum Path Sum](#64-Minimum-Path-Sum)
		* [62. Unique Paths](#62-Unique-Paths)
	* [Range](#Range)
		* [303. Range Sum Query](#303-Range-Sum-Query)
		* [413. Arithmetic Slices](#413-Arithmetic-Slices)
	* [Breakdown Number](#Breakdown-Number)
		* [343. Integer Break](#343-Integer-Break)
		* [279. Perfect Squares dup](#279-Perfect-Squares-dup) 
		* [91. Decode Ways](#91-Decode-Ways)
	* [Subsequence](#Subsequence)
		* [300. Longest Increasing Subsequence](#300-Longest-Increasing-Subsequence)
		* [646. Maximum Length of Pair Chain](#646-Maximum-Length-of-Pair-Chain)
		* [376. Wiggle Subsequence](#376-Wiggle-Subsequence)
		* [1143. Longest Common Subsequence](#1143-Longest-Common-Subsequence)
	* [01 Bag](#01-Bag)
		* [416. Partition Equal Subset Sum](#416-Partition-Equal-Subset-Sum)
		* [494. Target Sum](#494-Target-Sum)
		* [474. Ones and Zeroes](#474-Ones-and-Zeroes)
		* [322. Coin Change](#322-Coin-Change)
		* [518. Coin Change 2](#518-Coin-Change-2)
		* [377. Combination Sum IV](#377-Combination-Sum-IV)
		* [139. Word Break](#139-Word-Break)
	* [Stock Trade](#Stock-Trade)
		* [309. Best Time to Buy and Sell Stock with Cooldown](#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown)
		* [714. Best Time to Buy and Sell Stock with Transaction Fee](#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee)
		* [123. Best Time to Buy and Sell Stock III](#123-Best-Time-to-Buy-and-Sell-Stock-III)
		* [188. Best Time to Buy and Sell Stock IV](#188-Best-Time-to-Buy-and-Sell-Stock-IV)
	* [String Operations](#String-Operations)
		* [583. Delete Operation for Two Strings](#583-Delete-Operation-for-Two-Strings)
		* [72. Edit Distance](#72-Edit-Distance)
		* [650. 2 Keys Keyboard](#650-2-Keys-Keyboard)
		* [204. Count Primes](#204-Count-Primes)
		* [260. Single Number III](#260-Single-Number-III)
* [Math](#Math)
	* [204. Count Primes](#204-Count-Primes)
	* [Greatest Common Divisor](#Greatest-Common-Divisor)
	* [Least Common Multiple](#Least-Common-Multiple)
	* [172. Factorial Trailing Zeroes](#172-Factorial-Trailing-Zeroes)
	* [462. Minimum Moves to Equal Array Elements II](#462-Minimum-Moves-to-Equal-Array-Elements-II)
	* [169. Majority Element](#169-Majority-Element)
	* [367. Valid Perfect Square](#367-Valid-Perfect-Square)
	* [238. Product of Array Except Self](#238-Product-of-Array-Except-Self)
	* [628. Maximum Product of Three Numbers](#628-Maximum-Product-of-Three-Numbers)
* [Bit Computation](#Bit-Computation)
	* [504. Base 7](#504-Base-7)
	* [405. Convert a Number to Hexadecimal](#405-Convert-a-Number-to-Hexadecimal)
	* [168. Excel Sheet Column Title](#168-Excel-Sheet-Column-Title)
	* [67. Add Binary](#67-Add-Binary)
	* [415. Add Strings](#415-Add-Strings)
	* [461. Hamming Distance](#461-Hamming-Distance)
	* [136. Single Number](#136-Single-Number)
	* [268. Missing Number](#268-Missing-Number)
	* [exchange two integers without extra variables](#exchange-two-integers-without-extra-variables)
	* [190. Reverse Bits](#190-Reverse-Bits)
	* [231. Power of Two](#231-Power-of-Two)
	* [326. Power of Three](#326-Power-of-Three)
	* [342. Power of Four](#342-Power-of-Four)
	* [693. Binary Number with Alternating Bits](#693-Binary-Number-with-Alternating-Bits)
	* [476. Number Complement](#476-Number-Complement)
	* [371. Sum of Two Integers](#371-Sum-of-Two-Integers)

### Two Pointers
#### [167. Two Sum II](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)
```python
# Solution 1: two pointers - O(n) time and O(1) space
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        l, r = 0, len(numbers)-1
        while l < r:
            s = numbers[l] + numbers[r]
            if s == target:
                return [l+1, r+1]
            elif s > target:
                r -= 1
            else:
                l += 1
```

```python
# Solution 2: dictionary - O(n) time and O(n) space
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        dict = {}
        for idx, num in enumerate(numbers):
            if num in dict:
                return [dict[num] + 1, idx + 1]
            else:
                dict[target - num] = idx   
```

```python          
# Solution 3: binary search - O(nlogn) time and O(1) space
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        for i in range(len(numbers) - 1):
            tgt = target - numbers[i]
            l, r = i + 1, len(numbers) - 1
        
            while l <= r:
                mid = l + (r-l)//2

                if numbers[mid] == tgt:
                    return [i + 1, mid + 1]
                elif numbers[mid] < tgt:
                    l = mid + 1
                else:
                    r = mid - 1
```

#### [633. Sum of Square Numbers](https://leetcode.com/problems/sum-of-square-numbers/)
```python
# Solution 1: two pointers - O(sqrt(n)) time and O(1) space
class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        l, r = 0, int(sqrt(c))
        
        while l <= r:
            cur = l**2 + r**2
            
            if cur == c:
                return True
            elif cur < c:
                l += 1
            else:
                r -= 1
                
        return False
```

```python     
# Solution 2: hashset - O(sqrt(n)) time and O(sqrt(n)) space
class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        sqrtSet = set()
        
        for x in range(int(sqrt(c)) + 1):
            sqrtSet.add(x**2)
            
        for x in sqrtSet:
            if c - x in sqrtSet:
                return True
        
        return False
```

#### [345. Reverse Vowels of a String](https://leetcode.com/problems/reverse-vowels-of-a-string/) 
```python
class Solution:
    def reverseVowels(self, s: str) -> str:
        if s == None or len(s) == 0: 
            return s
        
        s = list(s)
        vows = set('aeiouAEIOU')
        
        l, r = 0, len(s) - 1
        while l < r:
            while l <= r and s[l] not in vows: 
                l += 1
            while l <= r and s[r] not in vows: 
                r -= 1
            if l > r: 
                break
                
            s[l], s[r] = s[r], s[l]
            l, r = l + 1, r - 1
            
        return ''.join(s)
```

#### [680. Valid Palindrome II](https://leetcode.com/problems/valid-palindrome-ii/)
```python
class Solution:
    def validPalindrome(self, s: str) -> bool:
        l, r = 0, len(s) - 1
        
        while l < r:
            if s[l] != s[r]:
                opt1 = s[l:r]
                opt2 = s[l + 1:r + 1]
                
                return opt1 == opt1[::-1] or opt2 == opt2[::-1]
            
            l, r = l + 1, r - 1
            
        return True
```        

#### [88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/)
```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        p1, p2 = m - 1, n - 1
        
        for p in range(n + m - 1, -1, -1):
            if p2 < 0:
                break
            if p1 >= 0 and nums1[p1] > nums2[p2]:
                    nums1[p] = nums1[p1]
                    p1 -= 1        
            else:
                nums1[p] = nums2[p2]
                p2 -= 1
```

#### [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        if head is None:
            return False
        
        slow = head
        fast = head.next
        
        while slow is not fast:
            if fast is None or fast.next is None:
                return False
            slow = slow.next
            fast = fast.next
        
        return True
```
Time complexity : O(n), where n is the total number of nodes in the linked list. 
Consider the following two cases separately.
1. List has no cycle:
The fast pointer reaches the end first and the run time depends on the list's length, which is O(n).

2. List has a cycle:
Consider breaking down the movement of the slow pointer into two steps, the non-cyclic part (N nodes) and the cyclic part (K nodes):
- The slow pointer takes "N" steps to enter the cycle. At this point, the fast pointer has already entered the cycle. Run time = N
- Both pointers are now in the cycle. Consider two runners running in a cycle - the fast runner moves 2 steps while the slow runner moves 1 steps at a time. To catch up with the slow runner, the number of steps that fast runner needs is (distance between the 2 runners)/(difference of speed). As the distance is at most "K" and the speed difference is 1, we conclude that run time = K

Therefore, the worst case time complexity is O(N+K), which is O(n).

#### [524. Longest Word in Dictionary through Deleting](https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/)
```python
class Solution:
    def findLongestWord(self, s: str, dictionary: List[str]) -> str:
        bestMatch = ""
        
        for word in dictionary:
            i = 0
            for char in s:
                if i < len(word) and char == word[i]:
                    i += 1
            
            if i == len(word):
                if (len(word) > len(bestMatch) or len(word) == len(bestMatch) and word < bestMatch):
                    bestMatch = word
                    
        return bestMatch
```

### Sorting

#### [215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)
top K elements method could be solved using heap or quick select
- heap: we use min-heap of size k to store the largest k elements (since the smallest element is popped out, what're left in the heap at the end are the largest k elements)
- quick select: based on quicksort using partition
```python
# Solution 1: sorting - O(nlogn) time and O(1) space
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums, reverse=True)[k-1]
```

```python
# Solution 2: heapsort - O(k + (n-k)logk) time and O(k) space
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        heap = []
        for n in nums:
            if len(heap) == k:
                heapq.heappushpop(heap, n)
            else:
                heapq.heappush(heap, n)
            
        return heapq.heappop(heap)
        # return heapq.nlargest(k, nums)[-1]
```

```python        
# Solution 3: quickselect - O(n) time and O(1) space
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        l, r = 0, len(nums) - 1
        
        while True:
            idx = self.partition(nums, l, r)
            
            if idx > k - 1:
                r = idx - 1
            elif idx < k - 1:
                l = idx + 1
            else:
                break
        
        return nums[idx]
        
    def partition(self, arr, start, end):
        pivot = arr[start]
        l = start + 1
        r = end
        
        while l <= r:
            if arr[l] < pivot and arr[r] > pivot:
                arr[l], arr[r] = arr[r], arr[l]
                l += 1
                r -= 1
            if arr[l] >= pivot:
                l += 1
            if arr[r] <= pivot:
                r -= 1
            
        arr[start], arr[r] = arr[r], arr[start] 
        return r # the position of the pivot
        
        # r will stop at a place where all numbers on the right are smaller than pivot, 
        # and l will stop at a place where all numbers on the left are bigger than pivot, including r (_ _ _ r l _ _). 
        # Thus swaping pivot and r gives the final list

```

#### [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)
```python
# Solution 1: bucket sort - O(n) time and O(n) space
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]: 
        freqMap = Counter(nums)
        
        max_freq = max(freqMap.values())
        buckets = [[] for _ in range(max_freq + 1)]  
        
        for num, freq in freqMap.items():
            buckets[freq].append(num)
        
        res = []
        for bucket in buckets[::-1]:
            if bucket:
                for num in bucket:
                    res.append(num)
                    
        return res[:k]
	
# Counter() is collections, and it has methods keys(), values(), items(), but it's not subscriptable, i.e., we cannot do Counter()[3]
# * Counter(nums).most_common(k) will return the result directly

# different ways to create frequency map
# 1. 
# freqMap = {}
# for num in nums:
# 	if num in d:
# 		freqMap[num] += 1
# 	else:
# 		freqMap[num] = 1
# 2.
# freqMap = collections.defaultdict(int)
# for num in nums:
#     freqMap[num] += 1
```
    
```python
# Solution 2: heap sort - O(nlogk) and O(n) space
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]: 
        freqMap = Counter(nums)

        heap = []
        for num, count in freqMap.items(): # O(nlog(k))
            if len(heap) == k:
                heappushpop(heap, (count, num))
            else:
                heappush(heap, (count, num))

        res = []
        while heap: # O(klogk)
            count, num = heappop(heap) 
            print(num, count)
            res.append(num)

        return res
```

#### [451. Sort Characters By Frequency](https://leetcode.com/problems/sort-characters-by-frequency/solution/)
```python
class Solution:
    def frequencySort(self, s: str) -> str:
        freqMap = collections.Counter(s)
        max_freq = max(freqMap.values())
        
        buckets = [[] for _ in range(max_freq + 1)]
        
        for num, count in freqMap.items():
            buckets[count].append(num)
            
        stringBuilder = []
        for count in range(len(buckets) - 1, 0, -1):
            for char in buckets[count]:
                stringBuilder.append(char * count)
    
        return "".join(stringBuilder)
```

#### [75. Sort Colors](https://leetcode.com/problems/sort-colors/)
```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        p0, p2 = 0, len(nums) - 1 
        curr = 0
        
        while curr <= p2:
            if nums[curr] == 0:
                nums[p0], nums[curr] = nums[curr], nums[p0]
                curr += 1
                p0 += 1
            elif nums[curr] == 2:
                nums[p2], nums[curr] = nums[curr], nums[p2]
                p2 -= 1
            else:
                curr += 1
```

### Greedy
#### [455. Assign Cookies](https://leetcode.com/problems/assign-cookies/)
```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        
        child, cookie = 0, 0
        while child < len(g) and cookie < len(s):
            if g[child] <= s[cookie]:
                child += 1
                cookie += 1
            else:
                cookie += 1
                
        return child
```

#### [435. Non overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)
for every selection, the end point is the most important - the smallest end point we choice, the more space left for the following intervals, and more intervals could be selected. We want to sort the intervals based on end point, and select the interval that has overlap with previous one each time.
```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        res = 0
        prevEnd = float('-inf')
        
        intervals.sort(key = lambda x: x[1]) # sort based on end point
        
        for intv in intervals:
            if intv[0] >= prevEnd: # non-overlap
                prevEnd = intv[1]
            else:
                res += 1  
        return res
```

#### [452. Minimum Number of Arrows to Burst Balloons](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/)
```python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        res = 0
        prevEnd = float('-inf')
        
        points.sort(key = lambda x: x[1])
        
        for intv in points:
            if intv[0] > prevEnd:
                res += 1
                prevEnd = intv[1]
                
        return res
```

#### [406. Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/description/)
Consider a queue with two 7-height people and one 6-height person. First, pick out tallest group of people (7-height) and sort them based on k. Since there's no other groups of people taller than them, each guy's index will be just as same as his k value.Now it's time to find a place for the guy of height 6. Since he is "invisible" for the 7-height guys, he could take whatever place without disturbing 7-height guys order. However, for him the others are visible, and hence he should take the position equal to his k-value, in order to have his proper place.

sorted List: [[7, 0], [7, 1], [6, 1], [5, 0], [5, 2], [4, 4]] <br />
[[7, 0]] <br />
[[7, 0], [7, 1]] <br />
[[7, 0], [6, 1], [7, 1]] <br />
[[5, 0], [7, 0], [6, 1], [7, 1]] <br />
[[5, 0], [7, 0], [5, 2], [6, 1], [7, 1]] <br />
[[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]] <br />

```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key = lambda x: (-x[0], x[1]))
        output = []
        
        for p in people:
            output.insert(p[1], p)
            
        return output
```

#### [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        minPrice = float('inf') # min price in "previous days"
        maxProfit = 0
        
        for price in prices:
            minPrice = min(price, minPrice)
            maxProfit = max(price - minPrice, maxProfit)
            
        return maxProfit
# the brute force will be having a nested for loops in O(n^2)
```

#### [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        profit = 0
        
        for i in range(1, len(prices)):
            if prices[i] > prices[i - 1]:
                profit += prices[i] - prices[i - 1]
                
        return profit
```

#### [392. Is Subsequence](https://leetcode.com/problems/is-subsequence/description/)
```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        for c in s:
            i = t.find(c)
            if i == -1:
                return False
            else:
                t = t[i + 1:]
        return True
# this problem can be solved easily by two pointers as well
```

#### [665. Non decreasing Array](https://leetcode.com/problems/non-decreasing-array/description/)
```python
class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        violated = False

        for i in range(1, len(nums)):
            if nums[i] < nums[i - 1]:
                if violated:
                    return False
                
                violated = True
                
                # when violation happens, nums[i - 1] > nums[i] 
                # we want to keep numbers as small as possible,
                # so that we have more flexibility with numbers later
                if i < 2 or nums[i - 2] <= nums[i]:
                    nums[i - 1] = nums[i] 
                else:
                    nums[i] = nums[i - 1]
                
        return True
```

#### [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/)
```python
# Solution 1: Greedy
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        for i in range(1, len(nums)):
            if nums[i-1] > 0:
                nums[i] += nums[i-1]
            else:
                continue
                
        return max(nums)

# ex.    [-2, 1, -3, 4, -1, 2, 1, -5, 4]
# nums = [-2, 1, -2, 4,  3, 5, 6,  1, 5]
```
```python
# Solution 2: devide and conquer
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        current_subarray = max_subarray = nums[0]
        
        for num in nums[1:]:
            # If current_subarray is negative, throw it away. Otherwise, keep adding to it.
            current_subarray = max(num, current_subarray + num)
            max_subarray = max(max_subarray, current_subarray)
        
        return max_subarray
```

#### [763. Partition Labels](https://leetcode.com/problems/partition-labels/description/)
```python
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        # ex. "abccaddbeffe"
        
        last = {c: i for i, c in enumerate(s)}
        
        anchor = 0
        p = 0
        res = []
        for i, c in enumerate(s):
            p = max(p, last[c])
            if i == p:
                res.append(i - anchor + 1)
                anchor = i + 1
                
        return res
```
### Divide and Conquer
#### [241. Different Ways to Add Parentheses](https://leetcode.com/problems/different-ways-to-add-parentheses/)
- The problem becomes easier when we think about these expressions as expression trees.
- We can traverse over the experssion and whenever we encounter an operator, we recursively divide the expression into left and right part and evaluate them seperately until we reach a situation where our expression is purely a number and in this case we can simply return that number.
- Since there can be multiple ways to evaluate an expression (depending on which operator you take first) we will get a list of reults from left and the right part.
- Now that we have all the possible results from the left and the right part, we can use them to find out all the possible results for the current operator.
- note, we create a memo to get answers for repeated calculation
<img src="https://github.com/lilywxc/Leetcode/blob/main/pictures/241.%20Different%20Ways%20to%20Add%20Parentheses.png" width="700">

ex. "2*3-4*5" <br />
[4] * [5] <br />
res: 4*5 [20] <br />
[3] - [20] <br />
res: 3-4*5 [-17] <br />
[3] - [4] <br />
res: 3-4 [-1] <br />
[-1] * [5] <br />
res: 3-4*5 [-17, -5] <br />
[2] * [-17, -5] <br />
res: 2*3-4*5 [-34] <br />
res: 2*3-4*5 [-34, -10] <br />
[2] * [3] <br />
res: 2*3 [6] <br />
[6] - [20] <br />
res: 2*3-4*5 [-34, -10, -14] <br />
[2] * [-1] <br />
res: 2*3-4 [-2] <br />
[6] - [4] <br />
res: 2*3-4 [-2, 2] <br />
[-2, 2] * [5] <br />
res: 2*3-4*5 [-34, -10, -14, -10] <br />
res: 2*3-4*5 [-34, -10, -14, -10, 10] <br />
```python
class Solution:
    def diffWaysToCompute(self, expression: str, memo = {}) -> List[int]:
     
        if expression.isdigit():
            return [int(expression)]
        
        if expression in memo:
            return memo[expression]
        
        res = []
        for i, c in enumerate(expression):
            if c in '*+-':
                left = self.diffWaysToCompute(expression[:i])
                right = self.diffWaysToCompute(expression[i+1:])
                
                # print(left, c, right)
                for x in left:
                    for y in right:
                        res.append(self.compute(x, y, c))
                        # print('res:', expression, res)
       
        memo[expression] = res
        return res
                
    def compute(self, x, y, op):
        if op == "+":
            return x + y
        elif op == "-":
            return x - y
        else:
            return x * y
```

#### [96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)
```python
class Solution:
    def numTrees(self, num: int) -> int:
        G = [0]*(num + 1)
        G[0], G[1] = 1, 1 
        
        for n in range(2, num + 1):
            for i in range(1, n + 1):
                G[n] += G[i - 1]*G[n - i]
                
        return G[num]
```

#### [95. Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:
        
        def generateTrees(start, end):
            if start > end:
                return [None, ]
            
            res = []
            for i in range(start, end + 1):
                left = generateTrees(start, i - 1)
                right = generateTrees(i + 1, end)
                
                for l in left:
                    for r in right:
                        current = TreeNode(i)
                        current.left = l
                        current.right = r
                        res.append(current)
                        
            return res
        
        return generateTrees(1, n) if n else []
```

### Binary Search
ordinary/original binary search
```python
def binarySearch(nums, key):
   l = 0
   r = len(nums) - 1
   
   while l <= r:
   	
	m = l + (r - l) // 2
	
	if nums[m] == key:
	    return m
	elif nums[m] > key:
            r = m - 1
        else:
            l = m + 1
  
    return -1
```

Variant example: find the leftmost match of a key in a non-decreasing array (has repeated numbers)
```python
def binarySearch(nums, key):
   l = 0
   r = len(nums) - 1
   
   while l < r:
   	
	m = l + (r - l) // 2
	
	if nums[m] >= key:
	    r = m
        else:
            l = m + 1
  
    return l
```
in this case where r is assigned m, we need while loop of l < r instead of l <= r to avoid possibly infinite loop

#### [69. Sqrt x](https://leetcode.com/problems/sqrtx/)
```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x < 2:
            return x
            
        l = 2
        r = x // 2
        
        while l <= r:
            m = l + (r - l)//2
            square = m * m
            
            if square == x:
	    	return m
	    elif square > x:
                r = m - 1
            else:
                l = m + 1
            
        return r
```
We return r (the smaller) when we break out the while loop. Consider one step earlier, l = r = m: 
- if m^2 > key, r = m - 1. We know r now is smaller than x cuz that's a previous location of l, meaning the square < x for sure. And l should not be the answer because l = m and we have evaluated that m^2 > key. r is the answer
- If m^2 < key, l = m + 1. We know l now is bigger than x cuz that's a previous location of r, meaning the square > x for sure. And r should be the answer because l = m and we have evaluated that m^2 > key.

#### [744. Find Smallest Letter Greater Than Target](https://leetcode.com/problems/find-smallest-letter-greater-than-target/)
```python
class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        l = 0
        h = len(letters) - 1
        
        while l <= h:
            m = l + (h - l) // 2
            
            if letters[m] <= target:
                l = m + 1
            else:
                h = m - 1
        
        return letters[l] if l < len(letters) else letters[0]
```

#### [540. Single Element in a Sorted Array](https://leetcode.com/problems/single-element-in-a-sorted-array/description/)
```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        l = 0
        h = len(nums) - 1
        
        while l < h:
            m = l + (h - l) // 2 
            
            if m % 2 == 1: # make sure m is at even idex
                m -= 1
                
            if nums[m] == nums[m + 1]:
                l = m + 2
            else:
                h = m
                
        return nums[l]
	# when we break out the while loop, l = r, so both index l and r of nunms is correct
```

#### [278. First Bad Version](https://leetcode.com/problems/first-bad-version/)
```python
# def isBadVersion(version: int) -> bool:

class Solution:
    def firstBadVersion(self, n: int) -> int:
        l = 0
        h = n
        
        while l < h:
            m = l + (h - l) // 2
            
            if isBadVersion(m):
                h = m
            else:
                l = m + 1
        
        return l
```

#### [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/submissions/)
the main idea for our checks is to converge the left and right bounds on the start
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l = 0
        h = len(nums) - 1
        
        while l < h:
            m = l + (h - l) // 2
            
            if nums[m] > nums[h]:
                l = m + 1
            else:
                h = m
                
        return nums[l]
```


#### [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        first = self.binarySearch(nums, target)
        
        if first == len(nums) or nums[first] != target:
            return [-1, -1]
        
        last = self.binarySearch(nums, target + 1) - 1
        
        return [first, last]
        
        
    def binarySearch(self, nums, key):
        l = 0
        r = len(nums)
        
        while l < r:
            m = l + (r - l) // 2

            if nums[m] >= key:
                r = m
            else:
                l = m + 1

        return l
```

### Search

#### BFS

#### [1091. Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/)
```python
class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        n = len(grid)
        
        if grid[0][0] or grid[n-1][n-1]:
            return -1
        
        directions = [[1,0], [-1,0], [0,1], [0,-1], [-1,-1], [1,1], [1,-1], [-1,1]]
        
        q = collections.deque([(0,0,1)]) 
        while q:
            i, j, dist = q.popleft()
            if i == n - 1 and j == n - 1: 
                return dist
            
            for d1, d2 in directions:
                x, y = i + d1, j + d2
                if 0 <= x < n and 0 <= y < n and grid[x][y] == 0:
                    grid[x][y] = 1
                    q.append((x, y, dist + 1))
                    
        return -1
```
note, if the input grid is not immutable, then we should have a set "seen" to store whether the cell has been visited or not, which takes O(N) - now the space is O(1) as we modify in place.

#### [279. Perfect Squares](https://leetcode.com/problems/perfect-squares/)
<img src="https://github.com/lilywxc/Leetcode/blob/main/pictures/279.%20Perfect%20Squares.png" width="550">

```python
# Solution 1: BFS
class Solution:
    def numSquares(self, n: int) -> int:
        square_nums = [i**2 for i in range(1, int(math.sqrt(n))+1)]
        
        level = 0
        queue = {n} # we normally use queue in BFS, but we use set here to
                    # eliminate the redundancy of remainders within the same level
        
        while queue:
            level += 1
            
            next_queue = set()
            for remainder in queue:
                for square_num in square_nums:
                    if square_num == remainder:
                        return level
                    elif square_num >= remainder:
                        break
                    else:
                        next_queue.add(remainder - square_num)
        
            queue = next_queue
    
        return level
```

```python
# Solution 2: DP - O(N*√N) time and O(N) space
# numSquares(n) = min(numSquares(n-k) + 1) ∀k∈{square numbers}
class Solution:
    def numSquares(self, n: int) -> int:

        square_nums = [i**2 for i in range(0, int(math.sqrt(n))+1)]
        
        dp = [float('inf')] * (n+1)
        dp[0] = 0 # base case
        
        for i in range(1, n+1):
            for square in square_nums:
                if i < square:
                    break
                dp[i] = min(dp[i], dp[i-square] + 1)
        
        return dp[-1]
```

#### [127. Word Ladder](https://leetcode.com/problems/word-ladder/)
```python
# BFS implementation using set
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        wordSet = set(wordList)
        if endWord not in wordSet: 
            return 0
            
        bq = {beginWord}
        eq = {endWord}
        dist = 1
        word_len = len(beginWord)
        
        while bq:
            dist += 1
            next_queue = set()
            wordSet -= bq # remove visited words
            
            for word in bq:
                for i in range(word_len):
                    for c in "abcdefghijklmnopqrstuvwxyz":
                        if c != word[i]:
                            new_word = word[:i] + c + word[i + 1:]
                             
                            if new_word in eq:                    
                                return dist
                            
                            if new_word in wordSet:
                                print(word, '->', new_word, dist)
                                next_queue.add(new_word)
                                wordSet.remove(new_word)
                                
            bq = next_queue
            if len(eq) < len(bq):
                bq, eq = eq, bq
                
        return 0
	
# BFS implementation using queue
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord not in set(wordList): 
            return 0
        
        # construct intermediate dict
        d = defaultdict(list)
        for word in wordList:
            for i in range(len(word)):
                s = word[:i] + "_" + word[i+1:]
                d[s].append(word)
            
        queue, visited = deque([(beginWord, 1)]), set()
        while queue:
            word, steps = queue.popleft()
            if word not in visited:
                visited.add(word)
                
                if word == endWord:
                    return steps
                
                for i in range(len(word)):
                    s = word[:i] + "_" + word[i+1:]
                    
                    for adj in d[s]:
                        if adj not in visited:
                            queue.append((adj, steps + 1))
        return 0
```

### DFS

#### [695. Max Area of Island](https://leetcode.com/problems/max-area-of-island/description/)
```python
# DFS recursive
class Solution:
    def maxAreaOfIsland(self, grid):
        nrow, ncol = len(grid), len(grid[0])

        def dfs(i, j):
            if 0 <= i < nrow and 0 <= j < ncol and grid[i][j]:
                grid[i][j] = 0 # mark visited cell in place, and get rid of seen set
                return 1 + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i + 1, j) + dfs(i, j - 1)
            
            return 0

        areas = [dfs(i, j) for i in range(nrow) for j in range(ncol) if grid[i][j]]
        
        return max(areas) if areas else 0
	
# DFS iterative
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        nrow, ncol = len(grid), len(grid[0])
        directions = [[1,0], [-1,0], [0,1], [0,-1]]
        seen = set()
        max_area = 0
        
        for r0 in range(nrow):
            for c0 in range(ncol):
                if grid[r0][c0] and (r0, c0) not in seen:
                    q = [(r0, c0)]
                    seen.add((r0, c0))
                    
                    cur_area = 0
                    while q:
                        r, c = q.pop()  # popleft() turns it to BFS 
                        cur_area += 1
                        
                        for d1, d2 in directions:
                            x, y = r + d1, c + d2
                            if 0 <= x < nrow and 0 <= y < ncol and grid[x][y] and (x, y) not in seen:
                                q.append((x, y))
                                seen.add((x, y))
                    
                    max_area = max(max_area, cur_area)
                    
        return max_area
```

#### [200. Number of Islands](https://leetcode.com/problems/number-of-islands/description/)
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        nrow, ncol = len(grid), len(grid[0])

        def dfs(x, y):
            if 0 <= x < nrow and 0 <= y < ncol and grid[x][y] == "1":
                grid[x][y] = "0"
                for i, j in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)):
                    dfs(i, j)

        num = 0
        for x in range(nrow):
            for y in range(ncol):
                if grid[x][y] == "1":
                    dfs(x, y)
                    num += 1
                    
        return num
```

#### [547. Number of Provinces](https://leetcode.com/problems/number-of-provinces/submissions/)
```python
class Solution:
    def findCircleNum(self, M: List[List[int]]) -> int:
        N = len(M)
        seen = set()
        
        def dfs(node):
            for adj, isConnected in enumerate(M[node]):
                if isConnected and adj not in seen:
                    seen.add(adj)
                    dfs(adj)

        num = 0
        for i in range(N):
            if i not in seen:
                dfs(i)
                num += 1
                
        return num
```

#### [130. Surrounded Regions](https://leetcode.com/problems/surrounded-regions/submissions/)
```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:

        if not any(board): 
            return

        m, n = len(board), len(board[0])
        
        border = [idx for k in range(max(m, n)) for idx in ((0, k), (m-1, k), (k, 0), (k, n-1))]

        while border:
            i, j = border.pop()
            if 0 <= i < m and 0 <= j < n and board[i][j] == 'O':
                board[i][j] = 'B'
                border += [(i, j-1), (i, j+1), (i-1, j), (i+1, j)]

        for row in board:
            for i, c in enumerate(row):
                row[i] = 'O' if c == 'B' else 'X'
```

#### [417. Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/)
```python
class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        if not heights:
            return []

        p_visited = set()
        a_visited = set()
        rows, cols = len(heights), len(heights[0])

        def dfs(i, j, visited):
            visited.add((i, j))
            
            for (x, y) in ((i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j)):
                if 0 <= x < rows and 0 <= y < cols and heights[x][y] >= heights[i][j] and (x, y) not in visited:
                    dfs(x, y, visited)

        for row in range(rows):
            dfs(row, 0, p_visited)
            dfs(row, cols - 1, a_visited)

        for col in range(cols):
            dfs(0, col, p_visited)
            dfs(rows - 1, col, a_visited)

        return list(p_visited.intersection(a_visited))
```

### Backtracking
the execution of the backtracking is unfolded as a DFS traversal in a n-ary tree. The total number of steps during the backtracking would be the number of nodes in the tree.

#### [17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/submissions/)
```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if len(digits) == 0: 
            return []
        
        letters = {"2": "abc", "3": "def", "4": "ghi", "5": "jkl", 
                   "6": "mno", "7": "pqrs", "8": "tuv", "9": "wxyz"}
        
        def backtrack(index, path):
            if len(path) == len(digits):
                combinations.append("".join(path))
                return 
            
            possible_letters = letters[digits[index]]
            for letter in possible_letters:
                path.append(letter)
                backtrack(index + 1, path)
                path.pop()

        combinations = []
        backtrack(0, [])
	
        return combinations
```

#### [78. Subsets](https://leetcode.com/problems/subsets/)
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        def backtrack(index, path):
            combinations.append(path[:])
            
            for i in range(index, n):
                path.append(nums[i])
                backtrack(i + 1, path)
                path.pop()
        
        n = len(nums)
        combinations = []
        backtrack(0, [])
            
        return combinations
```

#### [90. Subsets II](https://leetcode.com/problems/subsets-ii/)
```python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        def backtrack(index, path):
            combinations.append(path[:])
            
            for i in range(index, n):
                if i > index and nums[i] == nums[i - 1]:
                    continue
                    
                path.append(nums[i])
                backtrack(i + 1, path)
                path.pop()
        
        n = len(nums)
        nums.sort()
        combinations = []
        backtrack(0, [])
            
        return combinations
```

#### [77. Combinations](https://leetcode.com/problems/combinations/)
```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        def backtrack(index, path):
            if len(path) == k:
                combinations.append(path[:])
                return 
           
            for i in range(index, n):
                path.append(i + 1)
                backtrack(i + 1, path)
                path.pop()

        combinations = []
        backtrack(0, [])
	
        return combinations
```
		
#### [39. Combination Sum](https://leetcode.com/problems/combination-sum/)
```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        def backtrack(index, path, remain):
            if remain == 0:
                combinations.append(path[:])
                return 
            elif remain < 0:
                return
           
            for i in range(index, n):
                path.append(candidates[i])
                backtrack(i, path, remain - candidates[i]) # note we start at i again, as we are 
							   # allowed to use candidate multiple times
                path.pop()

        n = len(candidates)
        combinations = []
        backtrack(0, [], target)
	
        return combinations
```

#### [40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)
```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        def backtrack(index, path, remain):
            if remain == 0:
                combinations.append(path[:])
                return 
            elif remain < 0:
                return
           
            for i in range(index, n):
                if i > index and candidates[i] == candidates[i - 1]:
                    continue
                    
                path.append(candidates[i])
                backtrack(i + 1, path, remain - candidates[i])
                path.pop()

        n = len(candidates)
        candidates.sort()
        combinations = []
        backtrack(0, [], target)
	
        return combinations
```

#### [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/)
```python
class Solution:
    def combinationSum3(self, k: int, target: int) -> List[List[int]]:
        def backtrack(index, path, remain):
            if remain == 0 and len(path) == k:
                combinations.append(path[:])
                return 
            elif remain < 0 or len(path) == k:
                return
           
            for i in range(index, 9):
                path.append(i + 1)
                backtrack(i + 1, path, remain - (i + 1))
                path.pop()

        combinations = []
        backtrack(0, [], target)
	
        return combinations
```

#### [46. Permutations](https://leetcode.com/problems/permutations/)
<img src="https://github.com/lilywxc/Leetcode/blob/main/pictures/46.%20Permutations.png" width="700">

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:

        def backtrack(index):
            if index == n:
                ans.append(nums[:])
                
            for i in range(index, n):
                nums[index], nums[i] = nums[i], nums[index]
                backtrack(index + 1)
                nums[index], nums[i] = nums[i], nums[index]
                
        ans = []
        n = len(nums)
        backtrack(0)
        return ans
```

#### [47. Permutations II](https://leetcode.com/problems/permutations-ii/)
```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        def backtrack(path, counter):
            if len(path) == len(nums):
                results.append(path[:])
                return

            for num in counter:
                if counter[num] > 0:
                    path.append(num)
                    counter[num] -= 1
                    backtrack(path, counter)
                    path.pop()
                    counter[num] += 1

        results = []
        backtrack([], Counter(nums))

        return results
```

#### [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)
```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def backtracking(index, path):
            if index == n:
                res.append(path[:])
            
            for i in range(index, n):
                curr = s[index : i + 1] 
                
                if curr == curr[::-1]: # check palindrome
                    path.append(curr)
                    backtracking(i + 1, path)
                    path.pop()

        n = len(s)
        res = []
        backtracking(0, [])
        
        return res
```

#### [267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/)
```python
class Solution:
    def generatePalindromes(self, s: str) -> List[str]:
        counter = collections.Counter(s)
        mid = ''
        half = []
        for char, count in counter.items():
            q, r = divmod(count, 2)
            half += char * q
            
            if r == 1:
                if mid == '':
                    mid = char 
                else:
                    return [] # only one single char is acceptable
            
        def backtrack(path):
            if len(path) == n:
                cur = ''.join(path)
                ans.append(cur + mid + cur[::-1])
            else:
                for i in range(n):
                    if visited[i] or (i > 0 and half[i] == half[i-1] and not visited[i-1]):
                        continue
                    visited[i] = True
                    path.append(half[i])
                    backtrack(path)
                    visited[i] = False
                    path.pop()
                    
        ans = []
        n = len(half)
        visited = [False] * len(half)
        backtrack([])
        
        return ans
```

#### [93. Restore IP Addresses](https://leetcode.com/problems/restore-ip-addresses/)
```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        
        def backtrack(k, path, s):
            if k == 4:
                if len(s) == 0:
                    res.append('.'.join(path))
                else:
                    return
            
            for i in range(min(3, len(s))):
                if s[0] == '0' and i != 0:
                    break
                    
                part = s[0 : i + 1]

                print(s, part)
                if int(part) <= 255:
                    path.append(part)
                    backtrack(k + 1, path, s[i + 1:])
                    path.pop()
                        
        res = []
        backtrack(0, [], s)
        
        return res
```
#### [79. Word Search](https://leetcode.com/problems/word-search/)
```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:

        def backtrack(row, col, s):
            if len(s) == 0:
                return True

            if row < 0 or row == ROWS or col < 0 or col == COLS or board[row][col] != s[0]:
                return False

            ret = False
            board[row][col] = '#'
            
            for d1, d2 in directions:
                ret = backtrack(row + d1, col + d2, s[1:])
                if ret: 
                    break # no clean-up if we do "return True" here (sudden-death return)

            # revert the change
            board[row][col] = s[0]

            return ret
        
        ROWS = len(board)
        COLS = len(board[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        for row in range(ROWS):
            for col in range(COLS):
                if backtrack(row, col, word):
                    return True

        return False
```

#### [257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        if not root:
            return []
        
        def backtrack(root, path):

            path.append(str(root.val))

            if root.left:
                backtrack(root.left, path)
                path.pop()

            if root.right:
                backtrack(root.right, path)
                path.pop()

            if root.left is None and root.right is None:
                res.append('->'.join(path))
                
        
        res = []
        backtrack(root, [])
        
        return res
```

#### [37. Sudoku Solver](https://leetcode.com/problems/sudoku-solver/submissions/)
```python
from collections import defaultdict
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
                
        def is_valid(r, c, v):
            box_id = (r // 3) * 3 + c // 3
            return v not in rows[r] and v not in cols[c] and v not in boxes[box_id]


        def backtrack(r, c):
            if c == n:
                if r == n - 1:
                    return True
                else:
                    c = 0
                    r += 1

            if board[r][c] != '.':
                return backtrack(r, c + 1)

            box_id = (r // 3) * 3 + c // 3
            for v in range(1, 10):
                if not is_valid(r, c, v):
                    continue

                board[r][c] = str(v)
                rows[r].add(v)
                cols[c].add(v)
                boxes[box_id].add(v)

                if backtrack(r, c + 1):
                    return True

                # backtrack
                board[r][c] = '.'
                rows[r].remove(v)
                cols[c].remove(v)
                boxes[box_id].remove(v)

            return False

        
        n = len(board)
        rows, cols, boxes = defaultdict(set), defaultdict(set), defaultdict(set)

        for r in range(n):
            for c in range(n):
                if board[r][c] == '.':
                    continue

                v = int(board[r][c])
                rows[r].add(v)
                cols[c].add(v)
                boxes[(r // 3) * 3 + c // 3].add(v)
                
        backtrack(0, 0)
```

#### [51. N Queens](https://leetcode.com/problems/n-queens/description/)
```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        
        def create_board(board):
            res = []
            for row in board:
                res.append("".join(row))
            return res
        
        def backtrack(row, diagonals, anti_diagonals, cols, board):
            if row == n:
                ans.append(create_board(board))
                return

            for col in range(n):
                curr_diagonal = row - col
                curr_anti_diagonal = row + col
                
                if (col in cols or curr_diagonal in diagonals or curr_anti_diagonal in anti_diagonals):
                    continue

                cols.add(col)
                diagonals.add(curr_diagonal)
                anti_diagonals.add(curr_anti_diagonal)
                board[row][col] = "Q"

                backtrack(row + 1, diagonals, anti_diagonals, cols, board)

                cols.remove(col)
                diagonals.remove(curr_diagonal)
                anti_diagonals.remove(curr_anti_diagonal)
                board[row][col] = "."

        ans = []
        empty_board = [["."] * n for _ in range(n)]
        backtrack(0, set(), set(), set(), empty_board)
        
        return ans
```

### Dynamic Programming
Dynamic Programming is recursive approach with memorization

Example: Bowling
Given n pins 0, 1, ..., n-1, where pin i has value V_i. We get V_i point by hitting 1 pin i, and get V_i * V_i+1 by hitting 2 pins i and i + 1. We want to get max score.

**SORTBT**
- **S**ubproblem: B(i) = max score possible starting with pin i, i + 1, ..., n-1
- **O**riginal: B(0)
- **R**elate: B(i) = max{B(i+1), B(i+1) + V_i, B(i+2) + V_i*V_i+1}
- **T**opological order: decreasing i, i.e. for i = n, n-1, ...., 0
- **B**ase: B(n) = 0
- **T**ime: O(n)

Bottom up DP implementation
```python
base     B(n) = 0
topo     for i = n, n-1, ..., 0:
relate      B(i) = max{B(i+1), B(i+1) + V_i, B(i+2) + V_i*V_i+1}
original    return B(0)
```	
Good subproblem: 
- prefixes x[:i] O(n)
- suffixes x[i:] O(n)
- substrings x[i:j] O(n^2)

#### Fibonacci

#### [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/)
```python
# Solution 1: bottom up DP (constant space)
class Solution:
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        
        first, second = 1, 2
        
        for i in range(3, n + 1):
            tmp = first + second
            first = second
            second = tmp
            
        return second
	
# Solution 2: bottom up DP
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = {}
        dp[1] = 1
        dp[2] = 2
        
        for i in range(3, n+1):
            dp[i] = dp[i-1] + dp[i-2]

        return dp[n]

# Solution 3: top down DP
class Solution:
    def climbStairs(self, n: int) -> int:
        def climb(n):
            if n not in dic:
                dic[n] = climb(n-1) + climb(n-2)

            return dic[n]  
    
        dic = {1:1, 2:2}
        return climb(n)
```

#### [198. House Robber](https://leetcode.com/problems/house-robber/)
```python
# Solution 1: DP (constant space)
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        N = len(nums)
        rob_next_next = 0
        rob_next = nums[N - 1]
        
        for i in range(N - 2, -1, -1):
            maxRobbedAmount = max(rob_next, rob_next_next + nums[i])
            rob_next_next = rob_next
            rob_next = maxRobbedAmount
            
        return rob_next
            
# Solution 2: DP 
class Solution:
    def rob(self, nums: List[int]) -> int:
        # subproblem: suffix dp[i:]
        # topo. order: N, N-1, ..., 0
        
        if not nums:
            return 0
        
        N = len(nums)
        maxRobbedAmount = [None for _ in range(N + 1)]
        
        # Base case
        maxRobbedAmount[N], maxRobbedAmount[N - 1] = 0, nums[N - 1]
        
        # relate
        for i in range(N - 2, -1, -1):
            maxRobbedAmount[i] = max(maxRobbedAmount[i + 1], maxRobbedAmount[i + 2] + nums[i])
            
        # original
        return maxRobbedAmount[0] 
```

#### [213. House Robber II](https://leetcode.com/problems/house-robber-ii/)
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
          
        if not nums or len(nums) == 0:
            return 0
        
        if len(nums) == 1:
            return nums[0]
        
        def rob_helper(nums):
            N = len(nums)
            rob_next_next = 0
            rob_next = nums[N - 1]

            for i in range(N - 2, -1, -1):
                maxRobbedAmount = max(rob_next, rob_next_next + nums[i])
                rob_next_next = rob_next
                rob_next = maxRobbedAmount

            return rob_next
        
        return max(rob_helper(nums[1:]), rob_helper(nums[:-1]))
```

#### Mail Misalignment
有N个信和信封, 它们被打乱, 求错误装信方式的数量。

思路：定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：

- i == k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。
- i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。

综上所述，错误装信数量方式数量为：dp[i] = (i-1)*dp[i-2] + (i-1)*dp[i-1]

```python
def MailMisalignment(int n):
    if n == 0 or n == 1:
    	return 0
	
    dp = [None] * (n+1)
    dp[0] = 0
    dp[1] = 0
    dp[2] = 1
    
    for i in range(3, n):
        dp[i] = (i-1)*dp[i-2] + (i-1)*dp[i-1]
	
    return dp[n]
```

#### Cow
假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。

思路：dp数组存储每年成熟小母女的数量。因为只有成熟的母女才会继续生产牛。例：1，2，3，4，6 ... 即第N年后牛的数量等于第N - 1年牛的数量，加上第N - 3年成熟小母牛下的小母牛(3年成熟)。

状态转移方程：dp[i] = dp[i - 1] + dp[i - 3], n > 3
```python
def cow(int n):
    if i < 4:
    	return n
	
    dp = [None] * (n + 1)

    for i in range(5):
        dp[i] = i

    for i in range(5, n+1):
        dp[i] = dp[i - 1] + dp[i - 3]
   
    return dp[n]
```

#### Matrix Path

#### [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)
```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        
        # base case
        for i in range(1, n):
            grid[0][i] += grid[0][i-1]
        for i in range(1, m):
            grid[i][0] += grid[i-1][0]
            
        for i in range(1, m):
            for j in range(1, n):
                grid[i][j] += min(grid[i-1][j], grid[i][j-1])
                
        return grid[-1][-1]
```

#### [62. Unique Paths](https://leetcode.com/problems/unique-paths/description/)
```python
# Solution 1: DP
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        d = [[1] * n for _ in range(m)]

        for r in range(1, m):
            for c in range(1, n):
                d[r][c] = d[r - 1][c] + d[r][c - 1]

        return d[-1][-1]
```
```python
# Solution 2: Math
from math import factorial
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        return factorial(m + n - 2) // (factorial(n - 1) * factorial(m - 1))
```

### Range

#### [303. Range Sum Query](https://leetcode.com/problems/range-sum-query-immutable/)
```python
class NumArray:

    def __init__(self, nums: List[int]):
        self.preSum = nums
        for i in range(len(nums)-1):
            self.preSum[i+1] += self.preSum[i]
            
    def sumRange(self, left: int, right: int) -> int:
        if left == 0: 
            return self.preSum[right]
        
        return self.preSum[right] - self.preSum[left-1]
```

#### [413. Arithmetic Slices](https://leetcode.com/problems/arithmetic-slices/)
use dp[i] to store the number of arithmetic slices possible in the range (k,i), where k refers to the minimum index such that the range (k,i) constitutes a valid arithmetic slice, and (k,i) is not a part of any range (k,j) where j<i. 

consider the range (0, i-1), constituted by the elements a(0), ..., a(i-1). Let's denote the number of arithmetic slices as dp[i-1]. 

Now, add a new element a(i) with the same difference as previous ones. Note that a(1), ..., a(i) can be mapped perfectly to a(0), ..., a(i-1). Thus a(1), ..., a(i) has the same number of arithmetic slices as a(0), ..., a(i-1), which is dp[i-1]. 

And there is one more sequence: a(0), ..., a(i). Therefore, dp[i] = dp[i-1] + 1. And the total number of arithmetic slices in a(0), ..., a(i) is dp[i-1] + dp[i] = dp[i-1] + (dp[i-1] + 1)
```python
# Solution 1: DP
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [0] * n
        ans = 0
        for i in range(2, n):
            if nums[i-1] - nums[i-2] == nums[i] - nums[i-1]:
                dp[i] = dp[i-1] + 1
            ans += dp[i]
        return ans
    
# Solution 2: DP with constant space        
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums)
        dp, dpPrev = 0, 0
        ans = 0
        for i in range(2, n):
            if nums[i-1] - nums[i-2] == nums[i] - nums[i-1]:
                dp = dpPrev + 1
            ans += dp
            dpPrev = dp
            dp = 0
        return ans
```

#### Breakdown Number

#### [343. Integer Break](https://leetcode.com/problems/integer-break/description/)
write i as: i = j + S where S = i - j corresponds to either one number or a sum of two or more numbers
1. S is a single number: dp[i] = j * (i - j)
2. S is a sum of at least 2 numbers: dp[i] = j * dp[i - j]
```python
# Solution 1: DP
class Solution:
    def integerBreak(self, n: int) -> int:
        
        dp = [0] * (n + 1);
        dp[1] = 1
        
        for i in range(2, n + 1):
            for j in range(1, i):
                dp[i] = max(dp[i], max(j * dp[i - j], j * (i - j)))
    
        return dp[n]
```
```python
# Solution 2: Math
class Solution:
    def integerBreak(self, n: int) -> int:
        if n==2:
            return 1
        
        if n==3: 
            return 2
        
        product = 1
        while n > 4:
            product *= 3
            n -= 3
        
        product *= n;
        
        return product;
```

#### [279. Perfect Squares dup](https://leetcode.com/problems/perfect-squares/)
```python
# Solution 1: DP - O(N*√N) time and O(N) space
# numSquares(n) = min(numSquares(n-k) + 1) ∀k∈{square numbers}
class Solution:
    def numSquares(self, n: int) -> int:

        square_nums = [i**2 for i in range(0, int(math.sqrt(n))+1)]
        
        dp = [float('inf')] * (n+1)
        dp[0] = 0 # base case
        
        for i in range(1, n+1):
            for square in square_nums:
                if i < square:
                    break
                dp[i] = min(dp[i], dp[i-square] + 1)
        
        return dp[-1]
```
```python
# Solution 2: BFS
class Solution:
    def numSquares(self, n: int) -> int:
        square_nums = [i**2 for i in range(1, int(math.sqrt(n))+1)]
        
        level = 0
        queue = {n} # we normally use queue in BFS, but we use set here to
                    # eliminate the redundancy of remainders within the same level
        
        while queue:
            level += 1
            
            next_queue = set()
            for remainder in queue:
                for square_num in square_nums:
                    if square_num == remainder:
                        return level
                    elif square_num >= remainder:
                        break
                    else:
                        next_queue.add(remainder - square_num)
        
            queue = next_queue
    
        return level
```

#### [91. Decode Ways](https://leetcode.com/problems/decode-ways/description/)
```python
class Solution:
    def numDecodings(self, s: str) -> int:
        if not s:
            return 0

        n = len(s)
        dp = [0] * (n + 1)

        dp[0] = 1 
        dp[1] = 0 if s[0] == "0" else 1

        for i in range(2, len(s) + 1): 

            if 0 < int(s[i-1:i]) <= 9:
                dp[i] += dp[i - 1]

            if 10 <= int(s[i-2:i]) <= 26:
                dp[i] += dp[i - 2]
                
        return dp[len(s)]
```

#### Subsequence

#### [300. Longest Increasing Subsequence](#300-Longest-Increasing-Subsequence)
let dp[i] represents the length of the longest increasing subsequence that **ends with nums[i]**. Then, dp[i] = max(dp[j] + 1) for all j where nums[j] < nums[i] and j < i.
```python
# Solution 1: DP
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [1] * len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j] + 1)

        return max(dp)
```

Initialize an array sub which contains the first element of nums.
Iterate through the input, starting from the second element. For each element num: If num is greater than any element in sub, then add num to sub. Otherwise, iterate through sub and find the first element that is greater than or equal to num. Replace that element with num.
Return the length of sub.
```python
# Solution 2: math
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        def binarySearch(nums, key):
            l = 0
            r = len(nums) - 1

            while l < r:
                m = l + (r - l) // 2

                if nums[m] == key:
                    return m
                elif nums[m] > key:
                    r = m
                else:
                    l = m + 1

            return l
        
        sub = [nums[0]]
        for num in nums[1:]:
            if num > sub[-1]:
                sub.append(num)
            else:
                idx = binarySearch(sub, num)
                sub[idx] = num
        
        return len(sub)
```

#### [646. Maximum Length of Pair Chain](https://leetcode.com/problems/maximum-length-of-pair-chain/)
```python
# Solution 1: interval
class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        N = len(pairs)
        ans = 0
        pairs.sort(key = lambda x: x[1])

        prevEnd = float('-inf')
        for head, tail in pairs:
            if head > prevEnd:
                prevEnd = tail
                ans += 1
                
        return ans
```
```python
# Solution 2: DP
class Solution(object):
    def findLongestChain(self, pairs):
        pairs.sort()
        dp = [1] * len(pairs)

        for j in range(len(pairs)):
            for i in range(j):
                if pairs[i][1] < pairs[j][0]:
                    dp[j] = max(dp[j], dp[i] + 1)

        return max(dp)
```

#### [376. Wiggle Subsequence](https://leetcode.com/problems/wiggle-subsequence/)
```python
# Solution: greedy
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        
        if n < 2:
            return len(nums)

        length = 1
        sign = 0
        for i in range(1, n):
            if nums[i] < nums[i-1] and sign != -1: # peak
                sign = -1
                length += 1
            elif nums[i] > nums[i-1] and sign != 1: # valley
                sign = 1
                length += 1
       
        return length 
```

<img src="https://github.com/lilywxc/Leetcode/blob/main/pictures/376.%20Wiggle%20Subsequence.png" width="700">

```python
# Solution: space optimized DP
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        
        if n < 2:
            return len(nums)
        
        down, up = 1, 1
        
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                up = down + 1
            elif nums[i] < nums[i - 1]:
                down = up + 1
                
        return max(down, up)

# Solution: DP
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        
        if n < 2:
            return len(nums)
        
        up = [0] * n
        down = [0] * n
        
        for i in range(1, n):
            for j in range(i):
                if nums[i] > nums[j]:
                    up[i] = max(up[i], down[j] + 1)
                elif  nums[i] < nums[j]:
                    down[i] = max(down[i], up[j] + 1)
                    
        return 1 + max(down[n - 1], up[n - 1])
```

#### [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)

<img src="https://github.com/lilywxc/Leetcode/blob/main/pictures/1143.%20Longest%20Common%20Subsequence.png" width="350">

```python
# Solution: DP with space optimization
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        
        if len(text2) < len(text1):
            text1, text2 = text2, text1
   
        n1 = len(text1)
        n2 = len(text2)

        previous = [0] * (n1 + 1)
        current = [0] * (n1 + 1)
        
        # fix the suffix of text 2 (col), and iterate up each letter in text 1
        for col in range(n2 - 1, -1, -1):
            for row in range(n1 - 1, -1, -1):
                if text2[col] == text1[row]:
                    current[row] = 1 + previous[row + 1] # previous is the "t" col in graph
		    					 # previous[row + 1] is the yellow "2"
							 # current is the "a" col in graph
							 # curret[row] is the green "3"
                else:
                    current[row] = max(previous[row], current[row + 1])
                    
            previous, current = current, previous
        
        return previous[0]

# Solution: DP
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n1 = len(text1)
        n2 = len(text2)
        dp_grid = [[0] * (n2 + 1) for _ in range(n1 + 1)]
        
        for col in range(n2 - 1, -1, -1):
            for row in range(n1 - 1, -1, -1):
                if text2[col] == text1[row]:
                    dp_grid[row][col] = 1 + dp_grid[row + 1][col + 1]
                else:
                    dp_grid[row][col] = max(dp_grid[row + 1][col], dp_grid[row][col + 1])
        
        return dp_grid[0][0]
```

#### 01-Bag

有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。

定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：

- 第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。
- 第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。
第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：
```java
//W 为背包总体积
//N 为物品数量
//weights 数组存储 N 个物品的重量
//values 数组存储 N 个物品的价值
public int knapsack(int W, int N, int[] weights, int[] values) {
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = 1; j <= W; j++) {
            if (j >= w) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w] + v);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[N][W];
}
```

01背包的space optimization
在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。注意，要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。
```java
public int knapsack(int W, int N, int[] weights, int[] values) {
    int[] dp = new int[W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = W; j >= 1; j--) {
            if (j >= w) {
                dp[j] = Math.max(dp[j], dp[j - w] + v);
            }
        }
    }
    return dp[W];
}
```

Variants:
- 完全背包：物品数量为无限个
- 多重背包：物品数量有限制
- 多维费用背包：物品不仅有重量，还有体积，同时考虑这两种限制
- 其它：物品之间相互约束或者依赖

#### [416. Partition Equal Subset Sum](#416-Partition-Equal-Subset-Sum)
思路：背包大小为 total_sum//2 的0-1背包问题

dp[i][j] = true if the sum j can be formed by elements in subset {nums[0], ..., nums[i]}, otherwise dp[i][j] = false
dp[i][j] = true in two cases:
1. sum j can be formed without including nums[i], i.e., dp[i-1][j] == true
2. sum j can be formed by including nums[i], i.e., dp[i−1][j−nums[i]]==true

<img src="https://github.com/lilywxc/Leetcode/blob/main/pictures/416.%20Partition%20Equal%20Subset%20Sum.png" width="500">

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        '''
        dp[i][j] = true if the sum j can be formed by elements in 
        subset {nums[0], ..., nums[i]}
        '''
        total_sum = sum(nums)

        if total_sum % 2 != 0:
            return False
        
        subset_sum = total_sum // 2
        n = len(nums)

        dp = [[False] * (subset_sum + 1) for _ in range(n + 1)]
        dp[0][0] = True
        for i in range(1, n + 1):
            curr = nums[i - 1]
            for j in range(subset_sum + 1):
                if j < curr:
                    dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - curr]
        return dp[n][subset_sum]
	
# DP with constant space
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        total_sum = sum(nums)
        
        if total_sum % 2 != 0:
            return False
        
        subset_sum = total_sum // 2

        # construct a dp table of size (subset_sum + 1)
        dp = [False] * (subset_sum + 1)
        dp[0] = True
        for num in nums:
            for j in range(subset_sum, num - 1, -1):
                dp[j] = dp[j] or dp[j - num]

        return dp[subset_sum]
```

#### [494. Target Sum](https://leetcode.com/problems/target-sum/description/)
思路：背包大小为 target + sum(nums)//2 的0-1背包问题
```
                  sum(P) - sum(N) = target
sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)
                       2 * sum(P) = target + sum(nums)
		       	   sum[P] = [target + sum(nums)] // 2
```

dp[i][j] is the number of ways to make the subset_sum = j using elements in subset {nums[0], ..., nums[i]}       
```python
# DP
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        total_sum = sum(nums)
        
        if (total_sum + target) % 2 != 0 or total_sum < target:
            return 0
        
        subset_sum = (total_sum + target) // 2
        n = len(nums)
        
        dp = defaultdict(lambda: defaultdict(int)) # target could be negative, can't use array
        dp[0][0] = 1
        for i in range(1, n + 1):
            num = nums[i - 1]
            for j in range(subset_sum + 1):   
	    	if j < curr:
                    dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - num]
                
        return dp[n][subset_sum]
    
# space optimization
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        total_sum = sum(nums)
        
        if (total_sum + target) % 2 != 0 or total_sum < target:
            return 0
        
        subset_sum = (total_sum + target) // 2

        dp = defaultdict(int)
        dp[0] = 1
        for num in nums:
            for j in range(subset_sum, num - 1, -1):
                dp[j] = dp[j] + dp[j - num]
                
        return dp[subset_sum]
```
```python
# DFS
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        def findTarget(i, target):
            if (i, target) not in cache:
                r = 0
                
                if i == len(nums):
                    if target == 0:
                        r = 1
                else:
                    r = findTarget(i + 1, target - nums[i]) + findTarget(i + 1, target + nums[i])
                cache[(i, target)] = r
                
            return cache[(i, target)]
        
        cache = {}
        return findTarget(0, target)
```
```python
# BFS
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        count = defaultdict(int)
        count[0] = 1
        for x in nums:
            step = defaultdict(int)
            for y in count:
                step[y + x] += count[y]
                step[y - x] += count[y]
            count = step

        return count[target]
```

#### [474. Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/description/)
思路：多维费用的 0-1 背包问题，有两个背包大小，0 的数量和 1 的数量。
```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp = [[0] * (n + 1) for _ in range(m + 1)]
              
        for s in strs:
            zeros, ones = 0, 0
            
            for c in s:
                if c == '0':
                    zeros += 1
                else:
                    ones += 1
              
            for i in range(m, zeros - 1, -1):
                  for j in range(n, ones - 1, -1):
                        dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)
              
        return dp[m][n]
```

#### [322. Coin Change](https://leetcode.com/problems/coin-change/description/)
思路：完全背包问题, 只需要将 0-1 背包的逆序遍历 dp 数组改为正序遍历即可。
```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        n = len(coins)
        dp = [[float('inf')] * (amount + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        
        for i in range(1, n + 1):
            coin = coins[i - 1]
            for j in range(amount + 1):
                if j < coin:
                    dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - coin] + 1)
            
        return dp[n][amount] if dp[n][amount] != float('inf') else -1 
	
# space optimization
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount == 0:
            return 0
        
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] = min(dp[i], dp[i - coin] + 1)
                
        return dp[amount] if dp[amount] != float('inf') else -1 
```

#### [518. Coin Change 2](https://leetcode.com/problems/coin-change-2/description/)
思路：完全背包问题
```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        n = len(coins)
        dp = [[0] * (amount + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        
        for i in range(1, n + 1):
            coin = coins[i - 1]
            
            for j in range(amount + 1):
                if j < coin:
                    dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j] + dp[i][j - coin]
            
        return dp[n][amount]

# space optimization
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0] * (amount + 1)
        dp[0] = 1
	
        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] = dp[i] + dp[i - coin]
                
        return dp[amount]
```

#### [377. Combination Sum IV](377. Combination Sum IV)
```python
class Solution:
    def combinationSum4(self, nums: List[int], amount: int) -> int:
        dp = [0] * (amount + 1)
        dp[0] = 1

        for i in range(amount + 1):
            for num in nums:
                if i >= num:
                    dp[i] = dp[i] + dp[i - num]
                    
        return dp[amount]
```

#### [139. Word Break](https://leetcode.com/problems/word-break/)
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True

        for i in range(1, n + 1):
            for w in wordDict:
                if dp[i-len(w)] and s[i-len(w):i] == w:
                    dp[i] = True
                    break
        return dp[n]
```

#### Stock Trade

#### [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)
<img src="https://github.com/lilywxc/Leetcode/blob/main/pictures/309.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Cooldown.png" width="500">

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        sold, held, reset = float('-inf'), float('-inf'), 0

        for price in prices:
            pre_sold = sold
            sold = held + price
            held = max(held, reset - price)
            reset = max(reset, pre_sold)

        return max(sold, reset)
```

#### [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
If I am holding a share after today, then either 
1. I am just continuing holding the share I had yesterday, or 
2. I held no share yesterday, but bought in one share today
```
hold = max(hold, not_hold - prices[i])
```
If I am not holding a share after today, then either
1. I did not hold a share yesterday, or 
2. I held a share yesterday but I decided to sell it out today
```
not_hold = max(not_hold, hold + prices[i] - fee)
```
note that we can calculate "not_hold" first without using temporary variables because selling and buying on the same day can't be better than just continuing to hold the stock
```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        not_hold, hold = 0, -prices[0]
        
        for i in range(1, len(prices)):
            not_hold = max(not_hold, hold + prices[i] - fee)
            hold = max(hold, not_hold - prices[i])
            
        return not_hold
```

#### [123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/)

<img src="https://github.com/lilywxc/Leetcode/blob/main/pictures/123.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20III.png" width="700">

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        s1 = -prices[0]
        s2 = float('-inf')
        s3 = float('-inf')
        s4 = float('-inf')

        for i in range(1, len(prices)):           
            s1 = max(s1, - prices[i])
            s2 = max(s2, s1 + prices[i])
            s3 = max(s3, s2 - prices[i])
            s4 = max(s4, s3 + prices[i])
            print(prices[i], [s1, s2, s3, s4])
        return max(0, s4)
```
see Leetcode-188 below for generalization for k transactions

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        t1_cost, t2_cost = float('inf'), float('inf')
        t1_profit, t2_profit = 0, 0

        for price in prices:
            t1_cost = min(t1_cost, price)
            t1_profit = max(t1_profit, price - t1_cost)
            
            # reinvest the gained profit in the second transaction
            t2_cost = min(t2_cost, price - t1_profit)
            t2_profit = max(t2_profit, price - t2_cost)

        return t2_profit
```
see Leetcode-188 below for generalization for k transactions

#### [188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)
```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if k==0:
            return 0

        if 2*k >= len(prices): 
            return sum(max(0, prices[i]-prices[i-1]) for i in range(1, len(prices)))
    
    
        states = [0] + [-float('inf') for i in range(2*k)]
        states[1] = -prices[0]

        for i in range(1, len(prices)):
            for j in range(k):
                states[2*j + 1] = max(states[2*j + 1], states[2*j] - prices[i])
                states[2*j + 2] = max(states[2*j + 2], states[2*j + 1] + prices[i])

        return max(0, states[-1])
```


```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if k == 0:
            return 0
        
        if 2*k >= len(prices): 
            return sum(max(0, prices[i]-prices[i-1]) for i in range(1, len(prices)))
    
        profit = [0] * (k+1)
        cost = [float('inf')] * (k+1)

        profit[0] = 0
        
        for price in prices:
            for i in range(1, k + 1):
                cost[i] = min(cost[i], price - profit[i - 1])
                profit[i] = max(profit[i], price - cost[i])

        return profit[k]
```

Dynamic Programming approach (detailed version of solution #1)

dp[day_number][used_transaction_number][stock_holding_status]. The value of dp[i][j][l] represents the best profit we can have at the end of the i-th day, with j remaining transactions to make and l stocks.

- Keep holding the stock: dp[i][j][1] = dp[i-1][j][1]
- Keep not holding the stock: dp[i][j][0] = dp[i-1][j][0]
- Buying, when j>0: dp[i][j][1] = dp[i-1][j-1][0] - prices[i]
- Selling: dp[i][j][0] = dp[i-1][j][1] + prices[i]

We can combine they together to find the maximum profit:
- dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])
- dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)

        if k==0:
            return 0

        if 2*k >= len(prices): 
            return sum(max(0, prices[i]-prices[i-1]) for i in range(1, len(prices)))
    
        dp = [[[float('-inf')]*2 for _ in range(k + 1)] for _ in range(n)]
	
	dp[0][0][0] = 0
        dp[0][1][1] = -prices[0]

        for i in range(1, n):
            for j in range(k + 1):
                dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])
                if j > 0:
                    dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])

        res = max(dp[n-1][j][0] for j in range(k + 1))
        
        return res
```

#### String Operations

#### [583. Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/)
```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        '''
        this problem is equivalent to longest common substring
        '''
        m = len(word1)
        n = len(word2)
        
        dp = [[0] * (n+1) for _ in range(m+1)]
        
        for i in range(1, m+1):
            for j in range(1, n+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                    
        return m + n - 2 * dp[m][n]
```

#### [72. Edit Distance](#72-Edit-Distance)
```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n = len(word1)
        m = len(word2)
        
        # if one of the strings is empty
        if n * m == 0:
            return n + m
        
        d = [ [0] * (m + 1) for _ in range(n + 1)]
        
        for i in range(n + 1):
            d[i][0] = i
        for j in range(m + 1):
            d[0][j] = j
        
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if word1[i - 1] == word2[j - 1]:
                    d[i][j] = d[i-1][j-1]
                else:
                    d[i][j] = min(d[i-1][j], d[i][j-1], d[i-1][j-1]) + 1
        
        return d[n][m]
```

#### [650. 2 Keys Keyboard](https://leetcode.com/problems/2-keys-keyboard/)
```python
# DP
class Solution:
    def minSteps(self, n: int) -> int:
        dp = [0] * (n + 1)

        for i in range(2, n + 1):
            dp[i] = i # the possible maximum
            for j in range(1, i): # j is the existing 'A'
                if i % j == 0:
                    dp[i] = min(dp[i], dp[j] + (i//j))
                
        return dp[n]
```

We can break our moves into groups of (copy, paste, ..., paste). Let C denote copying and P denote pasting. 
Then for example, in the sequence of moves CPPCPPPPCP, the groups would be [CPP][CPPPP][CP].

Say these groups have lengths g_1, g_2, .... After parsing the first group, there are g_1 'A's. After parsing the second group, there are g_1 * g_2 'A's, and so on.
At the end, there are g_1 * g_2 * ... * g_n 'A's.

We want exactly N = g_1 * g_2 * ... * g_n. If any of the g_i are composite, say g_i = p * q, then we can split this group into two groups (the first of which has one copy followed by p-1 pastes, while the second group having one copy and q-1 pastes).
```python
class Solution:
    def minSteps(self, n: int) -> int:
        ans = 0
        d = 2
        
        while n > 1:
            while n % d == 0:
                ans += d
                n /= d
            d += 1
            
        return ans
```

### Math

#### [204. Count Primes](https://leetcode.com/problems/count-primes/)
```python
# Solution 1
class Solution:
    def countPrimes(self, n: int) -> int:
        if n <= 2:
            return 0
        
        primes = [False] * 2 + [True] * (n - 2)
        
        for i in range(2, int(sqrt(n)) + 1):
            if (primes[i] == True):
                for p in range(i * i, n, i):
                    primes[p] = False
                
               
        return sum(primes)
	
# Solution 2
class Solution:
    def countPrimes(self, n: int) -> int:
        notPrimes = [False] * n
        
        count = 0
        for i in range(2, n):
            if (notPrimes[i] == False):
                count += 1 
                
                j = 2
                while i * j < n:
                    notPrimes[i * j] = True
                    j += 1
                
               
        return count
```

#### Greatest Common Divisor
```python
def gcd(a, b):
	return b==0? a: gcd(b, a%b) 
```

对于 a 和 b 的最大公约数 f(a, b)：
- 如果 a 和 b 均为偶数，f(a, b) = 2*f(a/2, b/2)
- 如果 a 是偶数 b 是奇数，f(a, b) = f(a/2, b)
- 如果 b 是偶数 a 是奇数，f(a, b) = f(a, b/2)
- 如果 a 和 b 均为奇数，f(a, b) = f(b, a-b)

乘 2 和除 2 都可以转换为移位操作
```python
def gcd(a, b):
    if (a < b):
        return gcd(b, a)
  
    if (b == 0):
        return a
	
    isAEven, isBEven = isEven(a), isEven(b)
    if isAEven and isBEven:
        return 2 * gcd(a >> 1, b >> 1)
    elif isAEven and not isBEven:
        return gcd(a >> 1, b)
    elif not isAEven and isBEven:
        return gcd(a, b >> 1)
    else:
        return gcd(b, a - b)
```
note x >> y is equivalent to dividing x with 2^y, and x << y is equivalent to multiplying x with 2^y. 

#### Least Common Multiple
```python
def lcm(a, b):
	return a * b //gcd(a, b)
```

#### [172. Factorial Trailing Zeroes](https://leetcode.com/problems/factorial-trailing-zeroes/)
```python
class Solution:
    def trailingZeroes(self, n: int) -> int:
        '''
        fives = n/5 + (n/5)/5 + ((n/5)/5)/5 + ...
        '''
        zero_count = 0
        while n > 0:
            n //= 5
            zero_count += n
        return zero_count

#  O(logn)
class Solution:
    def trailingZeroes(self, n: int) -> int:
        zero_count = 0
        current_multiple = 5
        while n >= current_multiple:
            zero_count += n // current_multiple
            current_multiple *= 5
        return zero_count

    
# a better brute force - O(n)
class Solution:
    def trailingZeroes(self, n: int) -> int:
        zero_count = 0
        for i in range(5, n + 1, 5):
            current = i
            while current % 5 == 0:
                zero_count += 1
                current //= 5

        return zero_count

        
# brute force - factorial calc is worse than O(n)
def trailingZeroes(self, n: int) -> int:
        
    # Calculate n!
    n_factorial = 1
    for i in range(2, n + 1):
        n_factorial *= i
    
    # Count how many 0's are on the end.
    zero_count = 0
    while n_factorial % 10 == 0:
        zero_count += 1
        n_factorial //= 10
        
    return zero_count
```

#### [462. Minimum Moves to Equal Array Elements II](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/)
proof:

<img src="https://github.com/lilywxc/Leetcode/blob/main/pictures/462.%20Minimum%20Moves%20to%20Equal%20Array%20Elements%20II.png" width="900">

```python
class Solution(object):
    def minMoves2(self, nums):
        n = len (nums)
        mid = sorted (nums) [n // 2]
        res = sum (abs (i - mid) for i in nums)
        return res
```

#### [169. Majority Element](https://leetcode.com/problems/majority-element/description/)
given that it is impossible (in both cases) to discard more majority elements than minority elements, we are safe in discarding the prefix and attempting to recursively solve the majority element problem for the suffix. Eventually, a suffix will be found for which count does not hit 0, and the majority element of that suffix will necessarily be the same as the majority element of the overall array.
```python
# O(n) time and O(1) space
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 0
        candidate = None

        for num in nums:
            if count == 0:
                candidate = num
            count += (1 if num == candidate else -1)

        return candidate
```
```python
# O(n) time and O(n) space
class Solution:
    def majorityElement(self, nums):
        counts = collections.Counter(nums)
        return max(counts.keys(), key=counts.get)
```

#### [367. Valid Perfect Square](https://leetcode.com/problems/valid-perfect-square/)

<img src="https://github.com/lilywxc/Leetcode/blob/main/pictures/367.%20Valid%20Perfect%20Square.png" width="700">

```python
# Newton's Method
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        if num < 2:
            return True
        
        x = num // 2
        while x * x > num:
            x = (x + num // x) // 2
            
        return x * x == num
```
```python
# Binary search
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        if num < 2:
            return True
        
        l, r = 2, num // 2
        
        while l <= r:
            m = l + (r - l) // 2
        
            square = m * m
            if square == num:
                return True
            if square > num:
                r = m - 1
            else:
                l = m + 1
        
        return False
```

#### [238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/description/)
```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        length = len(nums)
        
        L, R, answer = [0]*length, [0]*length, [0]*length
        
        L[0] = 1
        for i in range(1, length):
            L[i] = nums[i - 1] * L[i - 1]
        
        R[length - 1] = 1
        for i in reversed(range(length - 1)):
            R[i] = nums[i + 1] * R[i + 1]
        
        for i in range(length):
            answer[i] = L[i] * R[i]
        
        return answer
    
# space optimziation
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        length = len(nums)
        answer = [0]*length
        answer[0] = 1
        
        for i in range(1, length):
            answer[i] = nums[i - 1] * answer[i - 1]
        
        R = 1
        for i in range(length-1, -1, -1):
            answer[i] = answer[i] * R
            R *= nums[i]
        
        return answer
```

#### [628. Maximum Product of Three Numbers](https://leetcode.com/problems/maximum-product-of-three-numbers/)
```python
class Solution:
    def maximumProduct(self, nums: List[int]) -> int:
        min1, min2 = float('inf'), float('inf')
        max1, max2, max3 = float('-inf'), float('-inf'), float('-inf')
        
        for n in nums:
            if n <= min1:
                min2 = min1
                min1 = n
            elif n <= min2:
                min2 = n
            
            if n >= max1:
                max3 = max2
                max2 = max1
                max1 = n
            elif n >= max2:
                max3 = max2
                max2 = n
            elif n >= max3:
                max3 = n
                
        return max(min1 * min2 * max1, max1 * max2 * max3)
```

### Bit Computation
**^**: 0^1 = 1, 1^1 = 0, 0^0 = 0
x ^ 0s = x      
x ^ 1s = ~x -> 位级反转     
x ^ x = 0   -> 去重    

**&**: 0&1 = 0, 1&1 = 1, 0&0 = 0 -> 掩码操作
x & 0s = 0      
x & 1s = x      
x & x = x      

**|**：0|1 = 1, 1|1 = 1, 0|0 = 0 -> 设值操作
x | 0s = x
x | 1s = 1s
x | x = x

useful tricks:
- x ^ x will remove all duplicates
- x & (x - 1) removes the rightmost bit of '1'
- x & (-x) will keep the rightmost bit of '1' and set all other bits to 0s, where -x = ~x + 1

#### [504. Base 7](https://leetcode.com/problems/base-7/)
7进制
```python
class Solution:
    def convertToBase7(self, num: int) -> str:        
        n, res = abs(num), ''
        
        if num== 0:
            return '0'
        
        while n:
            n, r = divmod(n, 7)
            res = str(r) + res

        return '-' * (num < 0) + res
```

#### [405. Convert a Number to Hexadecimal](https://leetcode.com/problems/convert-a-number-to-hexadecimal/description/)
16进制
```python
class Solution:
    def toHex(self, num: int) -> str:
        if num == 0: 
            return '0'
        
        num = num & 0xFFFFFFFF # same as num = num + 2**32
        dic = '0123456789abcdef'
        res = ''
        
        while num:
            num, r = divmod(num, 16)
            res = str(dic[r]) + res

        return res
```

#### [168. Excel Sheet Column Title](https://leetcode.com/problems/excel-sheet-column-title/)
26进制
```python
class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        if columnNumber == 0:
            return "" 

        q, r = divmod(columnNumber - 1, 26)
        return self.convertToTitle(q) + chr(r + ord('A'))
       
class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        res = ''
        while columnNumber:
            columnNumber, r = divmod(columnNumber - 1, 26)
            res = chr(r + ord('A')) + res
            
        return res
```

#### [67. Add Binary](https://leetcode.com/problems/add-binary/description/)
```python
# bit manipulation
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        # ex: a = '11', b = '1'
        x, y = int(a, 2), int(b, 2) # x = 3, y = 1

        while y:
            print('x, y:', x, y)
            answer = x ^ y
            print('x ^ y:', answer)
            carry = (x & y) << 1
            print('x & y << 1:', carry)
            x, y = answer, carry
            
        return bin(x)[2:]

# Bit-by-bit computation      
class Solution:
    def addBinary(self, a, b) -> str:
        n = max(len(a), len(b))
        a, b = a.zfill(n), b.zfill(n)
        
        carry = 0
        answer = []
        for i in range(n - 1, -1, -1):
            if a[i] == '1':
                carry += 1
            if b[i] == '1':
                carry += 1
                
            if carry % 2 == 1:
                answer.append('1')
            else:
                answer.append('0')
            
            carry //= 2
        
        if carry == 1:
            answer.append('1')
        answer.reverse()
        
        return ''.join(answer)
```

#### [415. Add Strings](https://leetcode.com/problems/add-strings/)
```python
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        res = []

        carry = 0
        p1 = len(num1) - 1
        p2 = len(num2) - 1
        while p1 >= 0 or p2 >= 0:
            x1 = ord(num1[p1]) - ord('0') if p1 >= 0 else 0
            x2 = ord(num2[p2]) - ord('0') if p2 >= 0 else 0
            
            carry, value = divmod(x1 + x2 + carry, 10)
            res.append(value)
            
            p1 -= 1
            p2 -= 1
        
        if carry:
            res.append(carry)
        
        return ''.join(str(x) for x in res[::-1])
```

#### [461. Hamming Distance](https://leetcode.com/problems/hamming-distance/)
```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        return bin(x ^ y).count('1')
```
```python
class Solution(object):
    def hammingDistance(self, x, y):
        xor = x ^ y
        count = 0
        while xor:
            print(xor, bin(xor)[2:], xor&1)
            if xor & 1:
                count += 1
            xor = xor >> 1
            
        return count
```
x & (x - 1) removes the rightmost bit of '1'
```python
class Solution:
    def hammingDistance(self, x, y):
        xor = x ^ y
        count = 0
        while xor:
            count += 1
            # remove the rightmost bit of '1'
            xor = xor & (xor - 1)
            
        return count
```

#### [136. Single Number](https://leetcode.com/problems/single-number/)
x ^ x = 0, x ^ 0 = x, (a ^ b) ^ c = a ^ (b ^ c) = (a ^ c) ^ b
```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        x = 0
        for i in nums:
            x = x ^ i
        return x
```

#### [268. Missing Number](https://leetcode.com/problems/missing-number/)
```python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        for i, num in enumerate(nums):
            n = n ^ i ^ num
            
        return n
```

#### [260. Single Number III](https://leetcode.com/problems/single-number-iii/description/)
x & (-x) will keep the rightmost bit of '1' and set all other bits to 0s, where -x = ~x + 1
```python
class Solution:
    def singleNumber(self, nums: int) -> List[int]:
    
        bitmask = 0
        for num in nums:
            bitmask = bitmask ^ num # filter out duplicates
            
        # rightmost 1-bit diff between x and y
        diff = bitmask & (-bitmask)
        
        x = 0
        for num in nums:
            if num & diff:
                x = x ^ num # filter out y and duplicates
        
        y = bitmask ^ x # filter out x
        return [x, y]
```

#### exchange two integers without extra variables
```python
a = a ^ b
b = a ^ b
a = a ^ b
```

#### [190. Reverse Bits](https://leetcode.com/problems/reverse-bits/description/)
```python
class Solution:
    def reverseBits(self, n: int) -> int:
        ret, power = 0, 31
        while n:
            ret += (n & 1) << power
            n = n >> 1
            power -= 1
        return ret
```

#### [231. Power of Two](https://leetcode.com/problems/power-of-two/)
a power of two in binary representation is one 1-bit, followed by some zeros, e.g., 2 = 10, 4 = 100, 8 = 1000. <br />
x & (-x) will keep the rightmost bit of '1' and set all other bits to 0s, where -x = ~x + 1. <br />
since a power of two contains just one 1-bit, this operation will result in the same x, i.e., x & (-x) == x. <br />
Other numbers have more than 1-bit in their binary representation and hence for them x & (-x) would not be equal to x itself.
```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n == 0:
            return False
        
        return n & (-n) == n
```
```python
class Solution(object):
    def isPowerOfTwo(self, n):
        if n == 0:
            return False
        return n & (n - 1) == 0
```
```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:  
        return n > 0 and bin(n).count("1") == 1
```


#### [326. Power of Three](https://leetcode.com/problems/power-of-three/description/)
```python
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        return n > 0 and (3**19) % n == 0
```

#### [342. Power of Four](https://leetcode.com/problems/power-of-four/)
Input number is known to be signed 32 bits integer, i.e. x <= 2^31 - 1. Hence the max power of four to be considered is log_4(2^31 - 1)] = 15. Voila, here is all 16 possible answers: 4^0, 4^1, ...4^15
```python
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        max_power = 15
        nums = [1] * (max_power + 1)
        
        for i in range(1, max_power + 1):
            nums[i] = 4 * nums[i - 1]
        
        return n in nums
```
If num is a power of four x = 4^a, then a = log_4(x) = (1/2)*log_2(x) is an integer. Thus, we simply need to check if log_2(2) is even
```python
from math import log2
class Solution:
    def isPowerOfFour(self, num: int) -> bool:
        return num > 0 and log2(num) % 2 == 0
```
In the case of power of four, 1-bit is at even position: bit 0, bit 2, bit 4, etc. e.g., 4 = 100, 8 = 10000 <br />
Hence, power of four would make a zero in a bitwise AND with number (101010...10)_2 = (aaaaaaaa)_16 = 0xaaaaaaaa
```python
class Solution:
    def isPowerOfFour(self, num: int) -> bool:
        return num > 0 and num & (num - 1) == 0 and num & 0xaaaaaaaa == 0
```

#### [693. Binary Number with Alternating Bits](https://leetcode.com/problems/binary-number-with-alternating-bits)
```python
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        '''
        n =         1 0 1 0 1 0 1 0
        n >> 1      0 1 0 1 0 1 0 1
        n ^ n>>1    1 1 1 1 1 1 1 1
        n           1 1 1 1 1 1 1 1
        n + 1     1 0 0 0 0 0 0 0 0
        n & (n+1)   0 0 0 0 0 0 0 0
        '''
        tmp = n ^ (n >> 1)
        return tmp & (tmp + 1) == 0
```

#### [476. Number Complement](https://leetcode.com/problems/number-complement/)
detailed picture explanation: [approach 4](https://leetcode.com/problems/number-complement/solution/)
```python
class Solution:
    def findComplement(self, num: int) -> int:
        # construct 1...1 bitmask with same length as num
        bitmask = num
        bitmask |= (bitmask >> 1)
        bitmask |= (bitmask >> 2)
        bitmask |= (bitmask >> 4)
        bitmask |= (bitmask >> 8)
        bitmask |= (bitmask >> 16)

        return bitmask ^ num
    
# a different way to create all-one mask with same length as num
# n = floor(log2(num)) + 1        
# bitmask = (1 << n) - 1
```

#### [371. Sum of Two Integers](https://leetcode.com/problems/sum-of-two-integers/)
similar question to [67. Add Binary](https://leetcode.com/problems/add-binary/description/)
```python
class Solution:
    def getSum(self, a: int, b: int) -> int:
        mask = 0xFFFFFFFF # bitmask of 32 1-bits
        while b != 0:
            answer = (a ^ b) & mask
            carry = ((a & b) << 1) & mask
            
            a, b = answer, carry
            
        max_int = 0x7FFFFFFF
        return a if a < max_int else ~(a ^ mask)
```
